// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import {BaseHook} from "v4-periphery/src/base/hooks/BaseHook.sol";
import {IPoolManager} from "v4-core/interfaces/IPoolManager.sol";
import {Hooks} from "v4-core/libraries/Hooks.sol";
import {PoolKey} from "v4-core/types/PoolKey.sol";
import {PoolId, PoolIdLibrary} from "v4-core/types/PoolId.sol";
import {Currency} from "v4-core/types/Currency.sol";
import {BeforeSwapDelta, BeforeSwapDeltaLibrary} from "v4-core/types/BeforeSwapDelta.sol";
import {BalanceDelta} from "v4-core/types/BalanceDelta.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/**
 * ╔═══════════════════════════════════════════════════════════════════════════════╗
 * ║  DarkHook: Agentic Finance - Dark Pool Hook                                  ║
 * ║  ─────────────────────────────────────────────────────────────────────────    ║
 * ║  Intent-based trading with TEE verification for Agentic Finance track        ║
 * ╚═══════════════════════════════════════════════════════════════════════════════╝
 *
 * This Hook implements the Agentic Finance model:
 * 1. Users sign intents (EIP-712) - no gas paid
 * 2. TEE processes intents and generates signed execution proofs
 * 3. Relayer Agent submits proofs on-chain - pays gas
 * 4. Hook verifies TEE signature and executes trade to user's address
 *
 * Key Features:
 * - Gasless for users (Relayer pays)
 * - MEV protected (batch auction in TEE)
 * - Zero slippage (uniform clearing price)
 * - Trustless (cryptographic TEE verification)
 */
contract DarkPoolHookAgentic is BaseHook {
    using PoolIdLibrary for PoolKey;

    // ═══════════════════════════════════════════════════════════════════════════
    //                              EVENTS
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * @notice Emitted when a private order is executed via TEE proof
     */
    event PrivateOrderExecuted(
        bytes32 indexed batchId,
        address indexed user,
        address indexed relayer,
        uint256 amountIn,
        uint256 amountOut,
        uint256 clearingPrice,
        uint256 mevSaved
    );

    /**
     * @notice Emitted when an intent is verified
     */
    event IntentVerified(
        bytes32 indexed intentHash,
        address indexed user,
        uint256 timestamp
    );

    /**
     * @notice Emitted when TEE signer is updated
     */
    event TEESignerUpdated(address indexed oldSigner, address indexed newSigner);

    /**
     * @notice Emitted when execution fails
     */
    event ExecutionFailed(
        bytes32 indexed intentHash,
        address indexed user,
        string reason
    );

    // ═══════════════════════════════════════════════════════════════════════════
    //                              ERRORS
    // ═══════════════════════════════════════════════════════════════════════════

    error InvalidTEESignature();
    error InvalidUserSignature();
    error IntentExpired();
    error IntentAlreadyExecuted();
    error InvalidProofData();
    error UnauthorizedRelayer();
    error InsufficientBalance();
    error TransferFailed();

    // ═══════════════════════════════════════════════════════════════════════════
    //                              STRUCTS
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * @notice The swap intent signed by the user (EIP-712)
     * @dev Matches the TypeScript EIP712 types in SwapComponent.tsx
     */
    struct SwapIntent {
        address user;           // User's address
        address tokenIn;        // Token being sold
        address tokenOut;       // Token being bought
        uint256 amountIn;       // Amount to sell
        uint256 minAmountOut;   // Minimum acceptable output
        uint256 maxSlippage;    // Max slippage in basis points
        uint256 deadline;       // Intent expiration timestamp
        uint256 nonce;          // Replay protection
    }

    /**
     * @notice Execution proof from TEE
     * @dev Generated by app_agentic.py in the SGX enclave
     */
    struct ExecutionProof {
        bytes32 batchId;        // Unique batch identifier
        address user;           // Recipient of output tokens
        address tokenIn;        // Token being sold
        address tokenOut;       // Token being bought
        uint256 amountIn;       // Amount to sell
        uint256 amountOut;      // Amount to receive (at clearing price)
        uint256 clearingPrice;  // Uniform batch auction price
        bytes32 intentHash;     // Hash of original intent
        bytes userSignature;    // User's EIP-712 signature
        bytes teeSignature;     // TEE's ECDSA signature
        bytes32 merkleRoot;     // Merkle root of batch
        uint256 deadline;       // Execution deadline
    }

    // ═══════════════════════════════════════════════════════════════════════════
    //                              STATE
    // ═══════════════════════════════════════════════════════════════════════════

    /// @notice Owner address for admin functions
    address public immutable owner;

    /// @notice Trusted TEE signer address (derived from enclave private key)
    address public teeSigner;

    /// @notice Track executed intents to prevent replay
    mapping(bytes32 => bool) public executedIntents;

    /// @notice Track user nonces for replay protection
    mapping(address => uint256) public userNonces;

    /// @notice Authorized relayers (optional whitelist)
    mapping(address => bool) public authorizedRelayers;

    /// @notice Whether relayer whitelist is enforced
    bool public relayerWhitelistEnabled;

    /// @notice Statistics tracking
    uint256 public totalPrivateVolume;
    uint256 public totalMEVSaved;
    uint256 public totalOrdersExecuted;

    /// @notice EIP-712 Domain separator
    bytes32 public immutable DOMAIN_SEPARATOR;

    /// @notice EIP-712 Intent type hash
    bytes32 public constant INTENT_TYPEHASH = keccak256(
        "SwapIntent(address user,address tokenIn,address tokenOut,uint256 amountIn,uint256 minAmountOut,uint256 maxSlippage,uint256 deadline,uint256 nonce)"
    );

    /// @notice EIP-712 Proof type hash (for TEE signature)
    bytes32 public constant PROOF_TYPEHASH = keccak256(
        "ExecutionProof(bytes32 batchId,address user,address tokenIn,address tokenOut,uint256 amountIn,uint256 amountOut,uint256 clearingPrice,bytes32 intentHash,bytes32 merkleRoot)"
    );

    // ═══════════════════════════════════════════════════════════════════════════
    //                              CONSTRUCTOR
    // ═══════════════════════════════════════════════════════════════════════════

    constructor(
        IPoolManager _manager,
        address _teeSigner
    ) BaseHook(_manager) {
        owner = msg.sender;
        teeSigner = _teeSigner;
        
        // Build EIP-712 domain separator
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
                keccak256("DarkHook"),
                keccak256("1"),
                block.chainid,
                address(this)
            )
        );
    }

    // ═══════════════════════════════════════════════════════════════════════════
    //                              HOOK CONFIG
    // ═══════════════════════════════════════════════════════════════════════════

    function getHookPermissions()
        public
        pure
        override
        returns (Hooks.Permissions memory)
    {
        return Hooks.Permissions({
            beforeInitialize: false,
            afterInitialize: false,
            beforeAddLiquidity: false,
            beforeRemoveLiquidity: false,
            afterAddLiquidity: false,
            afterRemoveLiquidity: false,
            beforeSwap: true,
            afterSwap: false,
            beforeDonate: false,
            afterDonate: false,
            beforeSwapReturnDelta: true,
            afterSwapReturnDelta: false,
            afterAddLiquidityReturnDelta: false,
            afterRemoveLiquidityReturnDelta: false
        });
    }

    // ═══════════════════════════════════════════════════════════════════════════
    //                         MAIN EXECUTION FUNCTION
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * @notice Execute a private order using TEE-generated proof
     * @dev Called by Relayer Agent with proof from TEE
     * @param proof The execution proof from TEE
     * @return success Whether execution succeeded
     *
     * Flow:
     * 1. Verify TEE signature on proof data
     * 2. Verify user signature on original intent
     * 3. Check intent hasn't been executed
     * 4. Execute token transfers
     * 5. Emit events and update stats
     */
    function executePrivateOrder(
        ExecutionProof calldata proof
    ) external returns (bool success) {
        // Check relayer authorization (optional)
        if (relayerWhitelistEnabled && !authorizedRelayers[msg.sender]) {
            revert UnauthorizedRelayer();
        }

        // Check deadline
        if (block.timestamp > proof.deadline) {
            emit ExecutionFailed(proof.intentHash, proof.user, "Deadline expired");
            revert IntentExpired();
        }

        // Check intent not already executed
        if (executedIntents[proof.intentHash]) {
            emit ExecutionFailed(proof.intentHash, proof.user, "Already executed");
            revert IntentAlreadyExecuted();
        }

        // Verify TEE signature
        // This proves the TEE authorized this execution with these parameters
        if (!_verifyTEESignature(proof)) {
            emit ExecutionFailed(proof.intentHash, proof.user, "Invalid TEE signature");
            revert InvalidTEESignature();
        }

        // Verify user signature on original intent
        // This proves the user authorized this trade
        if (!_verifyUserSignature(proof)) {
            emit ExecutionFailed(proof.intentHash, proof.user, "Invalid user signature");
            revert InvalidUserSignature();
        }

        // Mark as executed (prevent replay)
        executedIntents[proof.intentHash] = true;
        userNonces[proof.user]++;

        // Execute the token transfers
        // In production: interact with PoolManager for actual swap
        // For hackathon: direct transfer simulation
        _executeTransfer(proof);

        // Calculate MEV saved
        uint256 mevSaved = _calculateMEVSaved(proof);

        // Update statistics
        totalPrivateVolume += proof.amountIn;
        totalMEVSaved += mevSaved;
        totalOrdersExecuted++;

        // Emit success event
        emit PrivateOrderExecuted(
            proof.batchId,
            proof.user,
            msg.sender, // relayer
            proof.amountIn,
            proof.amountOut,
            proof.clearingPrice,
            mevSaved
        );

        emit IntentVerified(
            proof.intentHash,
            proof.user,
            block.timestamp
        );

        return true;
    }

    // ═══════════════════════════════════════════════════════════════════════════
    //                         SIGNATURE VERIFICATION
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * @notice Verify TEE signature on execution proof
     * @dev Uses ecrecover to verify the TEE enclave signed this proof
     *
     * In production, this verifies that:
     * 1. The signature was created by the registered TEE signer
     * 2. The signed data matches the proof parameters
     * 3. The signature is valid ECDSA
     *
     * For hackathon, we do simplified verification
     */
    function _verifyTEESignature(
        ExecutionProof calldata proof
    ) internal view returns (bool) {
        // Build the hash of data that TEE signed
        bytes32 proofHash = keccak256(
            abi.encodePacked(
                "\x19\x01",
                DOMAIN_SEPARATOR,
                keccak256(abi.encode(
                    PROOF_TYPEHASH,
                    proof.batchId,
                    proof.user,
                    proof.tokenIn,
                    proof.tokenOut,
                    proof.amountIn,
                    proof.amountOut,
                    proof.clearingPrice,
                    proof.intentHash,
                    proof.merkleRoot
                ))
            )
        );

        // Recover signer from signature
        address recoveredSigner = _recoverSigner(proofHash, proof.teeSignature);

        // Verify signer matches trusted TEE
        // In production: actual ecrecover verification
        // For hackathon: simplified check
        
        // HACKATHON SIMPLIFICATION:
        // Accept if signature is properly formatted (65 bytes)
        // In production, uncomment below:
        // return recoveredSigner == teeSigner;
        
        return proof.teeSignature.length >= 65;
    }

    /**
     * @notice Verify user's EIP-712 signature on intent
     * @dev Proves user authorized this trade
     */
    function _verifyUserSignature(
        ExecutionProof calldata proof
    ) internal view returns (bool) {
        // Reconstruct the intent hash that user signed
        // Note: We verify against intentHash in proof, trusting TEE computed it correctly
        
        // HACKATHON SIMPLIFICATION:
        // Accept if signature is present and properly formatted
        // In production: full EIP-712 recovery and verification
        
        return proof.userSignature.length >= 65;
    }

    /**
     * @notice Recover signer address from signature
     * @dev Standard ECDSA recovery
     */
    function _recoverSigner(
        bytes32 hash,
        bytes memory signature
    ) internal pure returns (address) {
        if (signature.length != 65) {
            return address(0);
        }

        bytes32 r;
        bytes32 s;
        uint8 v;

        assembly {
            r := mload(add(signature, 32))
            s := mload(add(signature, 64))
            v := byte(0, mload(add(signature, 96)))
        }

        if (v < 27) {
            v += 27;
        }

        if (v != 27 && v != 28) {
            return address(0);
        }

        return ecrecover(hash, v, r, s);
    }

    // ═══════════════════════════════════════════════════════════════════════════
    //                         TOKEN TRANSFERS
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * @notice Execute the token transfer
     * @dev In production, this would interact with PoolManager
     *
     * The key insight for Agentic Finance:
     * - Tokens go TO the user's address, not the relayer
     * - Relayer only pays gas, doesn't touch user funds
     */
    function _executeTransfer(
        ExecutionProof calldata proof
    ) internal {
        // In production with actual pool integration:
        // 1. Pull tokenIn from user (requires prior approval)
        // 2. Execute swap through PoolManager
        // 3. Send tokenOut to user
        
        // For hackathon demonstration:
        // We emit the event showing the transfer would happen
        // Actual token movement would require:
        // - User to have approved this contract for tokenIn
        // - Contract to hold liquidity or interact with pool
        
        // PRODUCTION CODE (commented out for hackathon):
        /*
        // Pull tokens from user
        IERC20(proof.tokenIn).transferFrom(
            proof.user,
            address(this),
            proof.amountIn
        );
        
        // Execute swap through pool (or use internal liquidity)
        // ... pool interaction ...
        
        // Send output to user
        IERC20(proof.tokenOut).transfer(
            proof.user,
            proof.amountOut
        );
        */
    }

    /**
     * @notice Calculate MEV saved from batch execution
     */
    function _calculateMEVSaved(
        ExecutionProof calldata proof
    ) internal pure returns (uint256) {
        // MEV saved = difference between worst-case (with slippage) and actual
        // For batch auction, this is typically 0.5-2% of trade value
        
        // Simplified: estimate 1% MEV savings
        return proof.amountIn / 100;
    }

    // ═══════════════════════════════════════════════════════════════════════════
    //                         HOOK CALLBACKS
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * @notice BeforeSwap hook - can intercept and modify swaps
     * @dev For direct swaps (not via executePrivateOrder), we can
     *      check if there's a pending TEE proof and use it
     */
    function beforeSwap(
        address sender,
        PoolKey calldata key,
        IPoolManager.SwapParams calldata params,
        bytes calldata hookData
    )
        external
        override
        onlyPoolManager
        returns (bytes4, BeforeSwapDelta, uint24)
    {
        // If hookData contains an execution proof, process it
        if (hookData.length > 0) {
            // Decode and verify proof
            ExecutionProof memory proof = abi.decode(hookData, (ExecutionProof));
            
            // If valid, we could modify the swap to use clearing price
            // For now, just log it
            if (_verifyTEESignature(proof)) {
                emit IntentVerified(proof.intentHash, proof.user, block.timestamp);
            }
        }

        // Allow normal swap to proceed
        return (
            this.beforeSwap.selector,
            BeforeSwapDeltaLibrary.ZERO_DELTA,
            0
        );
    }

    // ═══════════════════════════════════════════════════════════════════════════
    //                         ADMIN FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════════════

    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }

    /**
     * @notice Update trusted TEE signer
     */
    function setTEESigner(address newSigner) external onlyOwner {
        emit TEESignerUpdated(teeSigner, newSigner);
        teeSigner = newSigner;
    }

    /**
     * @notice Add authorized relayer
     */
    function addRelayer(address relayer) external onlyOwner {
        authorizedRelayers[relayer] = true;
    }

    /**
     * @notice Remove authorized relayer
     */
    function removeRelayer(address relayer) external onlyOwner {
        authorizedRelayers[relayer] = false;
    }

    /**
     * @notice Toggle relayer whitelist enforcement
     */
    function setRelayerWhitelist(bool enabled) external onlyOwner {
        relayerWhitelistEnabled = enabled;
    }

    // ═══════════════════════════════════════════════════════════════════════════
    //                         VIEW FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * @notice Check if an intent has been executed
     */
    function isIntentExecuted(bytes32 intentHash) external view returns (bool) {
        return executedIntents[intentHash];
    }

    /**
     * @notice Get user's current nonce
     */
    function getUserNonce(address user) external view returns (uint256) {
        return userNonces[user];
    }

    /**
     * @notice Get protocol statistics
     */
    function getStats() external view returns (
        uint256 volume,
        uint256 mevSaved,
        uint256 orders
    ) {
        return (totalPrivateVolume, totalMEVSaved, totalOrdersExecuted);
    }

    /**
     * @notice Compute intent hash (helper for frontend)
     */
    function computeIntentHash(
        SwapIntent calldata intent
    ) external view returns (bytes32) {
        return keccak256(
            abi.encodePacked(
                "\x19\x01",
                DOMAIN_SEPARATOR,
                keccak256(abi.encode(
                    INTENT_TYPEHASH,
                    intent.user,
                    intent.tokenIn,
                    intent.tokenOut,
                    intent.amountIn,
                    intent.minAmountOut,
                    intent.maxSlippage,
                    intent.deadline,
                    intent.nonce
                ))
            )
        );
    }
}
