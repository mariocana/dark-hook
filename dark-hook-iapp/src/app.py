#!/usr/bin/env python3
"""
╔═══════════════════════════════════════════════════════════════════════════════╗
║  UniShield: Agentic Finance - TEE Intent Matcher                              ║
║  ─────────────────────────────────────────────────────────────────────────    ║
║  Processes signed intents, executes batch auction, generates TEE signatures   ║
║  that can be verified on-chain by the Uniswap v4 Hook                        ║
╚═══════════════════════════════════════════════════════════════════════════════╝

This iApp runs inside an Intel SGX enclave via iExec infrastructure.
It implements an Intent-based flow for Agentic Finance:

1. Receives encrypted signed intents from users
2. Validates EIP-712 signatures
3. Executes batch auction matching
4. Generates ECDSA signature proving TEE authorization
5. Outputs execution proof for Relayer to submit on-chain
"""

import json
import hashlib
import hmac
import time
import os
import sys
import secrets
from typing import List, Dict, Tuple, Optional, Any
from dataclasses import dataclass, asdict, field
from enum import Enum
from decimal import Decimal

# ═══════════════════════════════════════════════════════════════════════════════
#                              CONFIGURATION
# ═══════════════════════════════════════════════════════════════════════════════

IEXEC_IN = os.environ.get("IEXEC_IN", "/iexec_in")
IEXEC_OUT = os.environ.get("IEXEC_OUT", "/iexec_out")

# TEE Private Key - In production, this would be derived from enclave sealing
# and protected by SGX. For hackathon, we use a deterministic key.
TEE_PRIVATE_KEY = os.environ.get(
    "IEXEC_APP_DEVELOPER_SECRET",
    "0x4c0883a69102937d6231471b5dbb6204fe512961708279e7f8b0b4d0df5c4e3a"
)

# TEE Public Address - Derived from private key, registered on-chain
TEE_SIGNER_ADDRESS = "0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf"

# Chain configuration
CHAIN_ID = 84532  # Base Sepolia
HOOK_CONTRACT = os.environ.get(
    "HOOK_CONTRACT",
    "0x0000000000000000000000000000000000000000"
)

# ═══════════════════════════════════════════════════════════════════════════════
#                              DATA STRUCTURES
# ═══════════════════════════════════════════════════════════════════════════════

@dataclass
class SwapIntent:
    """
    Represents a signed swap intent from a user.
    Matches the EIP-712 structure signed in the frontend.
    """
    user: str
    token_in: str
    token_out: str
    amount_in: int
    min_amount_out: int
    max_slippage: int  # basis points
    deadline: int
    nonce: int
    signature: str  # EIP-712 signature from user
    intent_hash: str


@dataclass 
class MatchedOrder:
    """Represents a matched order pair from batch auction."""
    buy_intent_hash: str
    sell_intent_hash: str
    execution_price: int
    buy_amount: int
    sell_amount: int
    buyer_address: str
    seller_address: str


@dataclass
class ExecutionProof:
    """
    The proof generated by TEE that the Relayer submits on-chain.
    Contains all data needed for the Hook to verify and execute.
    """
    # Batch identification
    batch_id: str
    timestamp: int
    
    # Matched trade details
    user: str
    token_in: str
    token_out: str
    amount_in: int
    amount_out: int
    clearing_price: int
    
    # Original intent reference
    intent_hash: str
    user_signature: str
    
    # TEE authorization
    tee_signature: str  # ECDSA signature from enclave
    tee_signer: str     # Address that signed (registered on-chain)
    
    # Merkle proof for batch inclusion (simplified)
    merkle_root: str
    
    # MEV savings calculation
    mev_saved: int


@dataclass
class BatchResult:
    """Complete result of batch processing."""
    batch_id: str
    clearing_price: int
    total_volume: int
    matched_orders: List[MatchedOrder]
    execution_proofs: List[ExecutionProof]
    total_mev_saved: int
    processing_time_ms: int
    enclave_measurement: str


# ═══════════════════════════════════════════════════════════════════════════════
#                              CRYPTOGRAPHIC ENGINE
# ═══════════════════════════════════════════════════════════════════════════════

class TEECryptoEngine:
    """
    Handles all cryptographic operations within the TEE.
    In production, would use actual ECDSA with secp256k1.
    """
    
    def __init__(self, private_key: str):
        self.private_key = private_key
        # In production: derive public key and address from private key
        self.signer_address = TEE_SIGNER_ADDRESS
    
    def sign_execution_proof(self, proof_data: Dict[str, Any]) -> str:
        """
        Generate ECDSA signature over execution proof data.
        
        In production, this would be:
        ```python
        from eth_account import Account
        from eth_account.messages import encode_structured_data
        
        typed_data = {
            "types": {
                "EIP712Domain": [...],
                "ExecutionProof": [
                    {"name": "batchId", "type": "bytes32"},
                    {"name": "user", "type": "address"},
                    {"name": "amountIn", "type": "uint256"},
                    {"name": "amountOut", "type": "uint256"},
                    {"name": "intentHash", "type": "bytes32"},
                ]
            },
            "domain": {...},
            "primaryType": "ExecutionProof",
            "message": proof_data
        }
        
        account = Account.from_key(self.private_key)
        signed = account.sign_message(encode_structured_data(typed_data))
        return signed.signature.hex()
        ```
        
        For hackathon, we generate a deterministic mock signature:
        """
        # Create deterministic data to sign
        sign_data = json.dumps(proof_data, sort_keys=True)
        
        # Generate signature components (r, s, v)
        # In production: actual ECDSA signing
        message_hash = hashlib.keccak_256(sign_data.encode()).digest()
        
        # Mock signature using HMAC (deterministic for testing)
        r = hmac.new(
            self.private_key.encode()[:32],
            message_hash + b"r",
            hashlib.sha256
        ).hexdigest()
        
        s = hmac.new(
            self.private_key.encode()[:32],
            message_hash + b"s", 
            hashlib.sha256
        ).hexdigest()
        
        v = "1b"  # 27 in hex (recovery id)
        
        return "0x" + r + s + v
    
    def compute_intent_hash(self, intent: SwapIntent) -> str:
        """Compute EIP-712 typed data hash for intent."""
        # In production: proper EIP-712 hashing
        data = f"{intent.user}:{intent.token_in}:{intent.token_out}:{intent.amount_in}:{intent.nonce}"
        return "0x" + hashlib.keccak_256(data.encode()).hexdigest()
    
    def verify_user_signature(self, intent: SwapIntent) -> bool:
        """
        Verify the user's EIP-712 signature on the intent.
        
        In production:
        ```python
        from eth_account.messages import encode_structured_data
        from eth_account import Account
        
        typed_data = create_eip712_typed_data(intent)
        recovered = Account.recover_message(
            encode_structured_data(typed_data),
            signature=intent.signature
        )
        return recovered.lower() == intent.user.lower()
        ```
        
        For hackathon, we accept all signatures:
        """
        # Verify signature is present and properly formatted
        if not intent.signature or len(intent.signature) < 130:
            return False
        
        # In production: actual ecrecover verification
        # For hackathon: always return True (trust frontend signing)
        print(f"[TEE] Verified signature for {intent.user[:10]}...")
        return True
    
    def compute_merkle_root(self, intent_hashes: List[str]) -> str:
        """Compute Merkle root of all intent hashes in batch."""
        if not intent_hashes:
            return "0x" + "0" * 64
        
        leaves = [bytes.fromhex(h.replace("0x", "")) for h in intent_hashes]
        
        while len(leaves) > 1:
            next_level = []
            for i in range(0, len(leaves), 2):
                left = leaves[i]
                right = leaves[i + 1] if i + 1 < len(leaves) else left
                combined = hashlib.keccak_256(left + right).digest()
                next_level.append(combined)
            leaves = next_level
        
        return "0x" + leaves[0].hex()
    
    def get_enclave_measurement(self) -> str:
        """Get SGX enclave measurement (MRENCLAVE)."""
        measurement_data = f"unishield_agentic_v1:{self.private_key[:16]}"
        return "0x" + hashlib.sha256(measurement_data.encode()).hexdigest()


# ═══════════════════════════════════════════════════════════════════════════════
#                              BATCH AUCTION ENGINE
# ═══════════════════════════════════════════════════════════════════════════════

class BatchAuctionEngine:
    """
    Implements Uniform Price Batch Auction for intent matching.
    
    The key insight: by processing all intents together and finding
    a single clearing price, we eliminate MEV and slippage.
    """
    
    def __init__(self, crypto: TEECryptoEngine):
        self.crypto = crypto
    
    def process_intents(
        self,
        buy_intents: List[SwapIntent],
        sell_intents: List[SwapIntent]
    ) -> Tuple[int, int, List[MatchedOrder]]:
        """
        Execute batch auction to find clearing price and matches.
        
        Returns:
            - clearing_price: Uniform execution price
            - total_volume: Total matched volume
            - matches: List of matched order pairs
        """
        if not buy_intents or not sell_intents:
            return 0, 0, []
        
        print(f"[TEE] Processing {len(buy_intents)} buys, {len(sell_intents)} sells")
        
        # Sort by price (buyers descending, sellers ascending)
        sorted_buys = sorted(
            buy_intents,
            key=lambda i: self._get_max_price(i),
            reverse=True
        )
        sorted_sells = sorted(
            sell_intents,
            key=lambda i: self._get_min_price(i)
        )
        
        # Find clearing price at supply/demand intersection
        clearing_price = self._find_clearing_price(sorted_buys, sorted_sells)
        
        if clearing_price == 0:
            print("[TEE] No clearing price found")
            return 0, 0, []
        
        print(f"[TEE] Clearing price: {clearing_price}")
        
        # Match orders at clearing price
        matches = self._generate_matches(
            sorted_buys, sorted_sells, clearing_price
        )
        
        total_volume = sum(m.buy_amount for m in matches)
        
        return clearing_price, total_volume, matches
    
    def _get_max_price(self, intent: SwapIntent) -> int:
        """Get maximum acceptable price for a buy intent."""
        # Calculate from slippage tolerance
        base_price = (intent.amount_in * 10**18) // max(intent.min_amount_out, 1)
        slippage_factor = 10000 + intent.max_slippage
        return (base_price * slippage_factor) // 10000
    
    def _get_min_price(self, intent: SwapIntent) -> int:
        """Get minimum acceptable price for a sell intent."""
        base_price = (intent.min_amount_out * 10**18) // max(intent.amount_in, 1)
        slippage_factor = 10000 - intent.max_slippage
        return (base_price * slippage_factor) // 10000
    
    def _find_clearing_price(
        self,
        buys: List[SwapIntent],
        sells: List[SwapIntent]
    ) -> int:
        """Find price where cumulative supply meets demand."""
        # Collect all price points
        price_points = set()
        for b in buys:
            price_points.add(self._get_max_price(b))
        for s in sells:
            price_points.add(self._get_min_price(s))
        
        best_price = 0
        best_volume = 0
        
        for price in sorted(price_points):
            demand = sum(
                b.amount_in for b in buys 
                if self._get_max_price(b) >= price
            )
            supply = sum(
                s.amount_in for s in sells
                if self._get_min_price(s) <= price
            )
            
            matched = min(demand, supply)
            if matched > best_volume:
                best_volume = matched
                best_price = price
        
        return best_price
    
    def _generate_matches(
        self,
        buys: List[SwapIntent],
        sells: List[SwapIntent],
        clearing_price: int
    ) -> List[MatchedOrder]:
        """Generate matched order pairs at clearing price."""
        matches = []
        
        eligible_buys = [b for b in buys if self._get_max_price(b) >= clearing_price]
        eligible_sells = [s for s in sells if self._get_min_price(s) <= clearing_price]
        
        buy_amounts = {b.intent_hash: b.amount_in for b in eligible_buys}
        sell_amounts = {s.intent_hash: s.amount_in for s in eligible_sells}
        
        for buy in eligible_buys:
            buy_remaining = buy_amounts.get(buy.intent_hash, 0)
            if buy_remaining <= 0:
                continue
            
            for sell in eligible_sells:
                sell_remaining = sell_amounts.get(sell.intent_hash, 0)
                if sell_remaining <= 0:
                    continue
                
                match_amount = min(buy_remaining, sell_remaining)
                if match_amount > 0:
                    matches.append(MatchedOrder(
                        buy_intent_hash=buy.intent_hash,
                        sell_intent_hash=sell.intent_hash,
                        execution_price=clearing_price,
                        buy_amount=match_amount,
                        sell_amount=match_amount,
                        buyer_address=buy.user,
                        seller_address=sell.user
                    ))
                    
                    buy_amounts[buy.intent_hash] -= match_amount
                    sell_amounts[sell.intent_hash] -= match_amount
                    buy_remaining -= match_amount
        
        return matches


# ═══════════════════════════════════════════════════════════════════════════════
#                              MAIN TEE APPLICATION
# ═══════════════════════════════════════════════════════════════════════════════

class UniShieldTEE:
    """
    Main TEE application orchestrating intent matching and proof generation.
    """
    
    def __init__(self):
        self.crypto = TEECryptoEngine(TEE_PRIVATE_KEY)
        self.auction = BatchAuctionEngine(self.crypto)
    
    def load_intents(self, input_path: str) -> List[SwapIntent]:
        """Load and validate intents from encrypted input."""
        print(f"[TEE] Loading intents from: {input_path}")
        
        try:
            with open(input_path, 'r') as f:
                data = json.load(f)
        except FileNotFoundError:
            print("[TEE] Input not found, using sample data")
            data = self._generate_sample_intents()
        
        intents = []
        for item in data.get("intents", data if isinstance(data, list) else []):
            try:
                intent = SwapIntent(
                    user=item["user"],
                    token_in=item["tokenIn"],
                    token_out=item["tokenOut"],
                    amount_in=int(item["amountIn"]),
                    min_amount_out=int(item["minAmountOut"]),
                    max_slippage=int(item.get("maxSlippage", 50)),
                    deadline=int(item.get("deadline", int(time.time()) + 3600)),
                    nonce=int(item.get("nonce", 1)),
                    signature=item.get("signature", "0x" + "0" * 130),
                    intent_hash=item.get("intentHash", "")
                )
                
                # Compute hash if not provided
                if not intent.intent_hash:
                    intent.intent_hash = self.crypto.compute_intent_hash(intent)
                
                # Verify user signature
                if self.crypto.verify_user_signature(intent):
                    intents.append(intent)
                else:
                    print(f"[TEE] Invalid signature for intent {intent.intent_hash[:10]}")
                    
            except (KeyError, ValueError) as e:
                print(f"[TEE] Skipping invalid intent: {e}")
        
        print(f"[TEE] Loaded {len(intents)} valid intents")
        return intents
    
    def _generate_sample_intents(self) -> Dict:
        """Generate sample intents for testing."""
        return {
            "intents": [
                # Buy intents (USDC -> ETH)
                {
                    "user": "0x742d35Cc6634C0532925a3b844Bc9e7595f8fE21",
                    "tokenIn": "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
                    "tokenOut": "0x4200000000000000000000000000000000000006",
                    "amountIn": str(1000 * 10**6),  # 1000 USDC
                    "minAmountOut": str(int(0.38 * 10**18)),  # 0.38 ETH
                    "maxSlippage": 50,
                    "deadline": int(time.time()) + 3600,
                    "nonce": 1,
                    "signature": "0x" + "a" * 130
                },
                {
                    "user": "0x8626f6940E2eb28930eFb4CeF49B2d1F2C9C1199",
                    "tokenIn": "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
                    "tokenOut": "0x4200000000000000000000000000000000000006",
                    "amountIn": str(2500 * 10**6),  # 2500 USDC
                    "minAmountOut": str(int(0.95 * 10**18)),  # 0.95 ETH
                    "maxSlippage": 100,
                    "deadline": int(time.time()) + 3600,
                    "nonce": 1,
                    "signature": "0x" + "b" * 130
                },
                # Sell intents (ETH -> USDC)
                {
                    "user": "0xdD2FD4581271e230360230F9337D5c0430Bf44C0",
                    "tokenIn": "0x4200000000000000000000000000000000000006",
                    "tokenOut": "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
                    "amountIn": str(int(0.5 * 10**18)),  # 0.5 ETH
                    "minAmountOut": str(1275 * 10**6),  # 1275 USDC (2550/ETH min)
                    "maxSlippage": 50,
                    "deadline": int(time.time()) + 3600,
                    "nonce": 1,
                    "signature": "0x" + "c" * 130
                },
                {
                    "user": "0x2546BcD3c84621e976D8185a91A922aE77ECEc30",
                    "tokenIn": "0x4200000000000000000000000000000000000006",
                    "tokenOut": "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
                    "amountIn": str(int(1.5 * 10**18)),  # 1.5 ETH
                    "minAmountOut": str(3825 * 10**6),  # 3825 USDC
                    "maxSlippage": 75,
                    "deadline": int(time.time()) + 3600,
                    "nonce": 1,
                    "signature": "0x" + "d" * 130
                }
            ]
        }
    
    def process_batch(self, intents: List[SwapIntent]) -> BatchResult:
        """Process all intents through batch auction."""
        start_time = time.time()
        
        print(f"[TEE] Processing batch of {len(intents)} intents")
        print(f"[TEE] Enclave: {self.crypto.get_enclave_measurement()[:20]}...")
        
        # Separate buy and sell intents
        # Buy = USDC -> ETH, Sell = ETH -> USDC
        usdc_addr = "0x036CbD53842c5426634e7929541eC2318f3dCF7e".lower()
        eth_addr = "0x4200000000000000000000000000000000000006".lower()
        
        buy_intents = [i for i in intents if i.token_in.lower() == usdc_addr]
        sell_intents = [i for i in intents if i.token_in.lower() == eth_addr]
        
        print(f"[TEE] Buy intents: {len(buy_intents)}, Sell intents: {len(sell_intents)}")
        
        # Run batch auction
        clearing_price, total_volume, matches = self.auction.process_intents(
            buy_intents, sell_intents
        )
        
        # Generate execution proofs for each matched order
        execution_proofs = []
        total_mev_saved = 0
        
        batch_id = "0x" + hashlib.keccak_256(
            f"{time.time()}:{len(intents)}:{clearing_price}".encode()
        ).hexdigest()[:16]
        
        intent_hashes = [i.intent_hash for i in intents]
        merkle_root = self.crypto.compute_merkle_root(intent_hashes)
        
        for match in matches:
            # Find original intents
            buy_intent = next((i for i in buy_intents if i.intent_hash == match.buy_intent_hash), None)
            sell_intent = next((i for i in sell_intents if i.intent_hash == match.sell_intent_hash), None)
            
            if not buy_intent or not sell_intent:
                continue
            
            # Calculate output amount at clearing price
            amount_out = (match.buy_amount * 10**18) // clearing_price
            
            # Calculate MEV saved (difference from worst-case slippage)
            worst_case = (buy_intent.amount_in * (10000 - buy_intent.max_slippage)) // 10000
            mev_saved = match.buy_amount - worst_case if match.buy_amount > worst_case else 0
            total_mev_saved += mev_saved
            
            # Create proof data to sign
            proof_data = {
                "batchId": batch_id,
                "user": buy_intent.user,
                "tokenIn": buy_intent.token_in,
                "tokenOut": buy_intent.token_out,
                "amountIn": match.buy_amount,
                "amountOut": amount_out,
                "clearingPrice": clearing_price,
                "intentHash": buy_intent.intent_hash,
                "merkleRoot": merkle_root,
                "timestamp": int(time.time())
            }
            
            # Generate TEE signature
            tee_signature = self.crypto.sign_execution_proof(proof_data)
            
            execution_proofs.append(ExecutionProof(
                batch_id=batch_id,
                timestamp=int(time.time()),
                user=buy_intent.user,
                token_in=buy_intent.token_in,
                token_out=buy_intent.token_out,
                amount_in=match.buy_amount,
                amount_out=amount_out,
                clearing_price=clearing_price,
                intent_hash=buy_intent.intent_hash,
                user_signature=buy_intent.signature,
                tee_signature=tee_signature,
                tee_signer=self.crypto.signer_address,
                merkle_root=merkle_root,
                mev_saved=mev_saved
            ))
            
            print(f"[TEE] Proof generated for {buy_intent.user[:10]}...")
        
        processing_time = int((time.time() - start_time) * 1000)
        
        return BatchResult(
            batch_id=batch_id,
            clearing_price=clearing_price,
            total_volume=total_volume,
            matched_orders=matches,
            execution_proofs=execution_proofs,
            total_mev_saved=total_mev_saved,
            processing_time_ms=processing_time,
            enclave_measurement=self.crypto.get_enclave_measurement()
        )
    
    def save_output(self, result: BatchResult, output_path: str):
        """Save execution proofs for Relayer consumption."""
        output = {
            "success": True,
            "batchId": result.batch_id,
            "clearingPrice": str(result.clearing_price),
            "totalVolume": str(result.total_volume),
            "totalMevSaved": str(result.total_mev_saved),
            "processingTimeMs": result.processing_time_ms,
            "enclaveMeasurement": result.enclave_measurement,
            "executionProofs": [
                {
                    "batchId": p.batch_id,
                    "timestamp": p.timestamp,
                    "user": p.user,
                    "tokenIn": p.token_in,
                    "tokenOut": p.token_out,
                    "amountIn": str(p.amount_in),
                    "amountOut": str(p.amount_out),
                    "clearingPrice": str(p.clearing_price),
                    "intentHash": p.intent_hash,
                    "userSignature": p.user_signature,
                    "teeSignature": p.tee_signature,
                    "teeSigner": p.tee_signer,
                    "merkleRoot": p.merkle_root,
                    "mevSaved": str(p.mev_saved)
                }
                for p in result.execution_proofs
            ],
            "metadata": {
                "version": "2.0.0",
                "app": "UniShield Agentic Finance TEE",
                "model": "intent-based",
                "chainId": CHAIN_ID
            }
        }
        
        os.makedirs(os.path.dirname(output_path) if os.path.dirname(output_path) else ".", exist_ok=True)
        
        with open(output_path, 'w') as f:
            json.dump(output, f, indent=2)
        
        print(f"[TEE] Output saved to: {output_path}")
        
        # iExec computed.json
        computed_path = os.path.join(os.path.dirname(output_path) or ".", "computed.json")
        with open(computed_path, 'w') as f:
            json.dump({"deterministic-output-path": output_path}, f)
    
    def run(self):
        """Main entry point."""
        print("=" * 70)
        print("  UniShield: Agentic Finance - TEE Intent Matcher")
        print("  Processing signed intents with batch auction matching")
        print("=" * 70)
        print()
        
        input_file = os.path.join(IEXEC_IN, "intents.json")
        output_file = os.path.join(IEXEC_OUT, "execution_proofs.json")
        
        if not os.path.exists(IEXEC_IN):
            input_file = "sample_intents.json"
            output_file = "execution_proofs.json"
        
        try:
            intents = self.load_intents(input_file)
            result = self.process_batch(intents)
            self.save_output(result, output_file)
            
            print()
            print("=" * 70)
            print("  TEE Processing Complete")
            print(f"  Batch ID: {result.batch_id}")
            print(f"  Clearing Price: {result.clearing_price}")
            print(f"  Proofs Generated: {len(result.execution_proofs)}")
            print(f"  Total MEV Saved: {result.total_mev_saved}")
            print("=" * 70)
            
        except Exception as e:
            error_output = {
                "success": False,
                "error": str(e),
                "errorType": type(e).__name__
            }
            with open(output_file, 'w') as f:
                json.dump(error_output, f, indent=2)
            print(f"[TEE] Error: {e}")
            sys.exit(1)


# ═══════════════════════════════════════════════════════════════════════════════
#                              ENTRY POINT
# ═══════════════════════════════════════════════════════════════════════════════

if __name__ == "__main__":
    app = UniShieldTEE()
    app.run()
